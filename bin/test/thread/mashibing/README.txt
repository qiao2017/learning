一个同步方法可以调用另外一个同步方法，一个线程已经拥有某个对象的锁，再次申请的时候仍然会得到该对象的锁.
也就是说synchronized获得的锁是可重入的

程序在执行过程中，如果出现异常，默认情况锁会被释放
所以，在并发处理的过程中，有异常要多加小心，不然可能会发生不一致的情况。
比如，在一个web app处理过程中，多个servlet线程共同访问同一个资源，这时如果异常处理不合适，
在第一个线程中抛出异常，其他线程就会进入同步代码区，有可能会访问到异常产生时的数据。
因此要非常小心的处理同步业务逻辑中的异常

锁定某对象o，如果o的属性发生改变，不影响锁的使用
但是如果o变成另外一个对象，则锁定的对象发生改变
应该避免将锁定对象的引用变成另外的对象

 * 当不涉及同步，只是涉及线程通信的时候，用synchronized + wait/notify就显得太重了
 * 这时应该考虑countdownlatch/cyclicbarrier/semaphore